# Требования: Рефакторинг маппинга product.id → offerId

## Введение

Текущая система использует кастомный атрибут `offerId_M2` в МойСклад для маппинга товаров. Однако это не соответствует реальным ограничениям API:

- **МойСклад webhook** отправляет только `product.id` (UUID товара)
- **Яндекс.Маркет API** работает только с `offerId` (стандартное поле)
- **M1 и M2** используют разные значения `offerId` для одного и того же товара

Необходимо переработать систему для использования файлового маппинга `product.id → offerId` вместо кастомного атрибута.

## Глоссарий

- **product.id**: UUID товара в МойСклад (например, `f8a2da33-bf0a-11ef-0a80-17e3002d7201`)
- **offerId**: Идентификатор товара в Яндекс.Маркет (стандартное поле)
- **offerId_M1**: Значение offerId для магазина M1 (например, `8100-X-clean-EFE-5w-30-5L`)
- **offerId_M2**: Значение offerId для магазина M2 (например, `8100-X-clean-EFE-5w-30-5L_DBSA`)
- **Mapping Table**: Файл JSON с маппингом `product.id → offerId_M2`
- **M1**: Магазин 1 на Яндекс.Маркет (использует встроенную интеграцию МойСклад)
- **M2**: Магазин 2 на Яндекс.Маркет (использует наш middleware)
- **Middleware**: Наше приложение-посредник между МойСклад и Яндекс.Маркет M2
- **Campaign ID**: Уникальный идентификатор магазина в Яндекс.Маркет

## Требования

### Требование 1: Файловое хранилище маппинга товаров

**User Story:** Как система, я хочу хранить маппинг между product.id и offerId в файле, чтобы не зависеть от кастомных атрибутов МойСклад.

#### Acceptance Criteria

1. WHEN система запускается THEN система SHALL загрузить маппинги из файла `data/product-mappings.json`
2. WHEN файл маппинга не существует THEN система SHALL создать пустой файл с корректной структурой
3. WHEN маппинг загружается THEN система SHALL валидировать структуру JSON
4. WHEN маппинг содержит невалидные данные THEN система SHALL логировать ошибку и пропускать невалидные записи
5. WHERE маппинг успешно загружен THEN система SHALL кэшировать маппинги в памяти для быстрого доступа

### Требование 2: Маппинг product.id на offerId для M2

**User Story:** Как система, я хочу преобразовывать product.id из МойСклад в offerId для M2, чтобы синхронизировать остатки с правильными товарами.

#### Acceptance Criteria

1. WHEN система получает product.id THEN система SHALL искать соответствующий offerId в таблице маппинга
2. WHEN маппинг найден THEN система SHALL вернуть offerId для M2
3. WHEN маппинг не найден THEN система SHALL логировать предупреждение и пропускать товар
4. WHEN система обрабатывает список product.id THEN система SHALL возвращать только те offerId, для которых есть маппинг
5. WHEN маппинг используется THEN система SHALL логировать операцию для отладки

### Требование 3: Изоляция M1 и M2

**User Story:** Как администратор системы, я хочу гарантировать полную изоляцию между M1 и M2, чтобы предотвратить конфликты и блокировку магазинов.

#### Acceptance Criteria

1. WHEN middleware обрабатывает товар THEN система SHALL использовать только offerId из таблицы маппинга
2. WHEN M1 синхронизирует товар THEN middleware SHALL не обрабатывать этот товар если его нет в таблице маппинга
3. WHEN M2 синхронизирует товар THEN система SHALL использовать Campaign ID M2
4. WHEN товар имеет маппинг THEN система SHALL отправлять данные только в M2 с соответствующим offerId
5. WHEN система работает THEN система SHALL никогда не читать или изменять стандартное поле product.offerId в МойСклад

### Требование 4: Webhook обработка с product.id

**User Story:** Как система, я хочу обрабатывать webhook от МойСклад с product.id, чтобы реагировать на изменения товаров в реальном времени.

#### Acceptance Criteria

1. WHEN webhook получен от МойСклад THEN система SHALL извлечь product.id из payload
2. WHEN product.id извлечен THEN система SHALL найти соответствующий offerId в таблице маппинга
3. WHEN маппинг найден THEN система SHALL обновить остатки в M2 используя найденный offerId
4. WHEN маппинг не найден THEN система SHALL логировать событие и игнорировать webhook
5. WHEN webhook обработан THEN система SHALL вернуть HTTP 200 OK

### Требование 5: Синхронизация остатков через product.id

**User Story:** Как система, я хочу синхронизировать остатки используя product.id, чтобы получать актуальные данные из МойСклад.

#### Acceptance Criteria

1. WHEN запускается синхронизация остатков THEN система SHALL получить список всех product.id из таблицы маппинга
2. WHEN список product.id получен THEN система SHALL запросить остатки из МойСклад по каждому product.id
3. WHEN остатки получены THEN система SHALL преобразовать product.id в offerId используя таблицу маппинга
4. WHEN offerId получен THEN система SHALL отправить обновление остатков в M2
5. WHEN синхронизация завершена THEN система SHALL логировать статистику (успешно/пропущено/ошибки)

### Требование 6: Удаление зависимости от атрибута offerId_M2

**User Story:** Как система, я хочу полностью удалить зависимость от кастомного атрибута offerId_M2, чтобы упростить архитектуру и соответствовать реальным ограничениям API.

#### Acceptance Criteria

1. WHEN система запускается THEN система SHALL не запрашивать метаданные атрибутов из МойСклад
2. WHEN система получает товары THEN система SHALL не использовать параметр `expand=attributes`
3. WHEN система работает THEN система SHALL не читать значения кастомных атрибутов
4. WHEN система маппит товары THEN система SHALL использовать только файловую таблицу маппинга
5. WHEN код выполняется THEN система SHALL не содержать ссылок на `offerId_M2` как атрибут

### Требование 7: Обработка заказов с offerId

**User Story:** Как система, я хочу обрабатывать заказы из M2 используя offerId, чтобы создавать корректные заказы в МойСклад.

#### Acceptance Criteria

1. WHEN заказ получен из M2 THEN система SHALL извлечь offerId из позиций заказа
2. WHEN offerId извлечен THEN система SHALL найти соответствующий product.id в обратном маппинге
3. WHEN product.id найден THEN система SHALL создать заказ в МойСклад используя product.id
4. WHEN product.id не найден THEN система SHALL логировать ошибку и пропускать позицию
5. WHEN заказ создан THEN система SHALL сохранить маппинг между M2 order ID и МойСклад order ID

### Требование 8: Обратный маппинг offerId → product.id

**User Story:** Как система, я хочу выполнять обратный маппинг offerId → product.id, чтобы обрабатывать заказы из M2.

#### Acceptance Criteria

1. WHEN система загружает маппинги THEN система SHALL построить обратный индекс offerId → product.id
2. WHEN система получает offerId THEN система SHALL искать соответствующий product.id в обратном индексе
3. WHEN обратный маппинг найден THEN система SHALL вернуть product.id
4. WHEN обратный маппинг не найден THEN система SHALL логировать предупреждение и вернуть null
5. WHEN обратный индекс используется THEN система SHALL обеспечить O(1) сложность поиска

### Требование 9: Логирование и мониторинг маппинга

**User Story:** Как администратор, я хочу видеть детальные логи операций маппинга, чтобы отлаживать проблемы и мониторить работу системы.

#### Acceptance Criteria

1. WHEN маппинг загружается THEN система SHALL логировать количество загруженных маппингов
2. WHEN маппинг не найден THEN система SHALL логировать product.id или offerId который не был найден
3. WHEN происходит ошибка маппинга THEN система SHALL логировать детали ошибки с контекстом
4. WHEN система работает THEN система SHALL предоставлять статистику маппинга через API
5. WHEN запрашивается статистика THEN система SHALL возвращать количество маппингов и статус загрузки

### Требование 10: Миграция существующих данных

**User Story:** Как администратор, я хочу мигрировать существующие данные из атрибутов в файловый маппинг, чтобы сохранить работоспособность системы.

#### Acceptance Criteria

1. WHEN запускается миграция THEN система SHALL прочитать все товары с атрибутом offerId_M2 из МойСклад
2. WHEN товары прочитаны THEN система SHALL создать маппинг product.id → offerId_M2
3. WHEN маппинг создан THEN система SHALL сохранить его в файл `data/product-mappings.json`
4. WHEN миграция завершена THEN система SHALL логировать количество мигрированных записей
5. WHEN миграция выполнена THEN система SHALL создать резервную копию старого файла маппинга если он существовал
